|------------------------------------------------------|
|-------------checking necessary software--------------|
|------------------------------------------------------|
Find perl:/usr/bin/perl
Find git:/usr/bin/git
Find svn:/usr/bin/svn
|------------------------------------------------------|
|             set current testing project              |
|             Example 1 : ./run.sh chart 1             |
|             Example 2 : ./run.sh math 1              |
|------------------------------------------------------|
TEST :  closure_21
Profl test coverage file= /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/21.txt
Profl method coverage file= /mnt/efs/fs1/XiaInformation/AllMethods/Closure/21.txt
Profl failing test file= /mnt/efs/fs1/XiaInformation/FailingTests/Closure/21.txt
|------------------------------------------------------|
|         checkout project from the Internet           |
|------------------------------------------------------|
[NOT] Removing directory]
Save closure-21 to /home/ubuntu/repair-tool/simfix/d4j/projects/closure/closure_21_buggy
|------------------------------------------------------|
|                     run simfix                       |
|------------------------------------------------------|
Executing Profl-based Simfix
Setting profl parameter to /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/21.txt from '--profl_test=/mnt/efs/fs1/XiaInformation/LineCoverage/Closure/21.txt'
Setting profl parameter to /mnt/efs/fs1/XiaInformation/AllMethods/Closure/21.txt from '--profl_method=/mnt/efs/fs1/XiaInformation/AllMethods/Closure/21.txt'
Setting profl parameter to /mnt/efs/fs1/XiaInformation/FailingTests/Closure/21.txt from '--profl_fail=/mnt/efs/fs1/XiaInformation/FailingTests/Closure/21.txt'
/home/ubuntu/repair-tool/simfix/d4j/projects
=================================================
Project : closure_21	start : 20/05/29 10:51

Field type inconsistancy 'THIS' with types : Token and int
Variable type inconsistancy of 'name' in method 'visit,NodeTraversal,Node,Node' with types : Name and String
Field type inconsistancy 'SUPER' with types : SimpleReference<SimpleSlot> and FunctionInjector.Reference
Variable type inconsistancy of 'start' in method 'parseRegExp,String,String' with types : int and char
Variable type inconsistancy of 'end' in method 'parseRegExp,String,String' with types : int and char
Field type inconsistancy 'errors' with types : JSError[] and List<JSError>
Field type inconsistancy 'type' with types : Type and JSType
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
[Originally FAILING test case] com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode

Reading test line coverage from /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/21.txt
Reading method line coverage from /mnt/efs/fs1/XiaInformation/AllMethods/Closure/21.txt
Writing sbfl final results to /home/ubuntu/repair-tool/simfix/runnable/proflResults/closure_21/generalSusInfo.profl
TIMEOUT : 18000000
Modified method com.google.javascript.rhino.Token:name(I)Ljava/lang/String; at line=187
Modified method com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V at line=115
Modified method com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V at line=118
======== PATCH BEGIN ========
if(ancestorType==Token.BLOCK)continue;
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 120 to 120
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoneFix detected
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_3_mod1_21.tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
int ancestorType=ancestor.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.SCRIPT)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoneFix detected
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_13_mod2_21.tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
beforeChild=an;
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
swtich (parent.getType()){
case Token.SETTER_DEF :

case Token.GETTER_DEF :

case Token.STRING_KEY :
return parent.getString();

case Token.NUMBER :
return getStringValue(parent);

}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
handleUnresolvedType(t,true);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
super.visit(t,n,parent);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
parent.addChildToBack(an);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
checkNoTypeCheckSection(n,true);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(!(ancestorType==Token.BLOCK||pType==Token.SCRIPT||pType==Token.NAME||pType==Token.ASSIGN||pType==Token.STRING_KEY)){
return false;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
int ancestorType=parent.getParent().getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoisyFix detected!
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_259_mod1_21.tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
int ancestorType=parent.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoisyFix detected!
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_259_mod2_21.tests
======== PATCH BEGIN ========
for(Node an : parent.getAncestors()){
this.isLoop=ancestorType==Token.DO||ancestorType==Token.WHILE||ancestorType==Token.FOR;
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
an=n;
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkNotNull(problemNodes,"\"replacements\" is null.");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(problemNodes.size()==1||ancestorType==Token.BLOCK||parentType==Token.SCRIPT||parentType==Token.LABEL);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(ancestorType!=Token.GETPROP&&type!=Token.GETELEM&&type!=Token.CALL){
replaceWithNull(parent,parent);
break;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(t.getScopeDepth()<2){
return ;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoneFix detected
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_369_mod1_21.tests
======== PATCH BEGIN ========
if(n.isQualifiedName()&&n.getJSDocInfo()!=null){
return ;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoneFix detected
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_449_mod1_21.tests
======== PATCH BEGIN ========
if(parent.getParent()==null){
return false;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(an.isNew(),"Expected: NEW, Got: %s",Token.name(node.getType()));
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(getType(parent.getFirstChild()).isUnknownType()||type.isUnionType()){
return false;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
case Token.FUNCTION :

for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
case Token.AND :

for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(NodeUtil.isObjectLitKey(n,n.getParent())||ancestorType==Token.NAME||nType==Token.GETPROP);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkNotNull(parent);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(parent.getType()==Token.BLOCK);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
parent=child.getFirstChild();
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument((n.isAnd())||(node.isOr()),"Expected: AND or OR, Got: %s",Token.name(node.getType()));
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(parent!=null&&node.parent==this,"The existing child node of the parent should not be null.");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(newChild.next==null,"The new child node has siblings.");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(newChild.parent==null,"The new child node already has a parent.");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(PROTECTOR_FN==null){
return parent;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
setPosition(an);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(!(parent.isExprResult()&&parent.getParent().isScript())){
t.report(n,NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR);
return ;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(parent.isObjectLit());
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
super.visit(t,parent,parent);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(an.isCall(),"Expected: CALL, Got: %s",Token.name(node.getType()));
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(!NodeUtil.functionCallHasSideEffects(an)){
return true;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
parent.replaceChild(n,IR.string(PROTECTOR_FN.substring(ancestorType,index+1)));
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
reportCodeChange();
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(n.hasOneChild());
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
parent.replaceChild(n,IR.number(PROTECTOR_FN.charAt(ancestorType)));
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(parent.getJSDocInfo()==null&&parent.isVar()&&parent.hasOneChild()){
info=parent.getJSDocInfo();
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(parent!=null){
PROTECTOR_FN=getFunctionName(parent)+"::";
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
PROTECTOR_FN=str.replaceAll("::this\\.",".");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
if(!parent.isNumber()){
return n;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
case Token.FOR :

for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(isResultUsed==true);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(child.parent==null);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkArgument(child.next==null);
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
child.parent=this;
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
child.next=parent;
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
parent=parent;
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
File modified = com.google.javascript.jscomp.CheckSideEffects from lines 118 to 123
Method modified = com.google.javascript.jscomp.CheckSideEffects:visit(Lcom/google/javascript/jscomp/NodeTraversal;Lcom/google/javascript/rhino/Node;Lcom/google/javascript/rhino/Node;)V
NoneFix detected
-------- PROCESSING TESTS END --------
Test suite failed: /home/ubuntu/repair-tool/simfix/runnable/log/closure/Attempt_1025_mod5_21.tests
======== PATCH BEGIN ========
if(!(parent.isScript()||parent.getParent()!=null&&grandparent.isFunction()&&parent.isBlock())){
return ;
}
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
Preconditions.checkState(parent.hasOneChild());
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
Build failed !
Compilation failed, skipping tests
======== PATCH BEGIN ========
new StringBuilder(32).append("function (");
for(Node an : parent.getAncestors()){
int ancestorType=an.getType();
if(ancestorType==Token.COMMA)continue;
if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;
}
-------- PATCH END --------
-------- PROCESSING TESTS BEGIN --------
TESTING single test: com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode
TESTING test suite for: closure_21
[NOT] Removing directory
|------------------------------------------------------|
|------------------------Finish------------------------|
  Summary:
   * log file:
      ./runnable/log/closure/21.txt
   * patch folder (if success):
      ./runnable/patch/closure/21
